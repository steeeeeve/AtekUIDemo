
Meteor.utilFunctions = {

    getUserSettings : function() {
        var data;
        var settings = {};
        data = Assets.getText("user_settings.json");
        settings = JSON.parse(data);
        return settings;
    },

}

var verifyAndSaveDCCredentials = function (creds) {
    console.log('verify and save ', creds);
    var curUser = Meteor.user();
    if (curUser) {
        // verify creds against device cloud by asking for users 1st device
        options = {
            auth: creds.username+':'+creds.password
        };
        result = HTTP.get('http://my.idigi.com/ws/DeviceCore/.json?size=1', options);
        if (result.statusCode===200) {
            // success! salt away the credentials for later dc work
            // todo store credentials under this userid
            Meteor.users.update({_id:curUser._id}, {$set:{'profile.dcCreds':creds}});
        };
        return {statusCode: result.statusCode};
    }
    return null;
};

var getDCCredentials = function() {
    var curUser = Meteor.user();
    if (curUser) {
        if (curUser.profile.dcCreds) {
            return curUser.profile.dcCreds;
        }
        // TODO: temp hack to bind working dc credentials to this account. Eventually remove and bind
        // these through application config settings
        var result = verifyAndSaveDCCredentials({username: 'JeffRyanDemo', password:'JeffRyanDemo1!'});
        console.log('DC Credential verification results: ', result);
        if (curUser.profile.dcCreds) { // try again after our hack above
            return curUser.profile.dcCreds;
        }
    }
    return null;
}

Accounts.onCreateUser(function(options, user){
    console.log('creating user:'+user.emails[0].toString());
    var cust = Customers.find().fetch()[Math.floor(Customers.find().fetch().length*Math.random())];
    //var cust = Customers.findOne();
    console.log('binding user to customer '+cust.name);
    user.profile = {customerId: cust._id};
    return user;
});


// sample server function that returns a json object
Meteor.startup(function() {

    console.log("Starting Meteor Server...");

    /* Get user settings from the file system */
    var userSettings = Meteor.utilFunctions.getUserSettings();

    /* Ensure they gave good Device Cloud data */
    if (!userSettings.hasOwnProperty('device_cloud')) {
        throw new Error("User Settings must include Device Cloud information!");
    }

    framework = new Framework(this, userSettings.device_cloud);

    Customers = framework.add_standard_collection(framework.CollectionType.CUSTOMERS,
        "customers", CustomerSchema);
    Sites = framework.add_standard_collection(framework.CollectionType.SITES,
        "sites", SiteSchema);
    Gateways = framework.add_standard_collection(framework.CollectionType.GATEWAYS,
        "gateways", GatewaySchema);
    Devices = framework.add_standard_collection(framework.CollectionType.DEVICES,
        "devices", DeviceSchema);
    Channels = framework.add_standard_collection(framework.CollectionType.CHANNELS,
        "channels", ChannelSchema);
    ChannelsHistory = framework.add_standard_collection(framework.CollectionType.CHANNELS_HISTORY,
        "channels_history", null);
//    DeviceCore = framework.add_standard_collection(framework.CollectionType.DEVICE_CORE,
//        "device_core", DeviceCoreSchema);
    DeviceCoreHistory = framework.add_standard_collection(framework.CollectionType.DEVICE_CORE_HISTORY,
        "device_core_history", null);
//    DataStream = framework.add_standard_collection(framework.CollectionType.DATA_STREAM,
//        "data_stream", DataStreamSchema);
//    DataPoint = framework.add_standard_collection(framework.CollectionType.DATA_POINT,
//        "data_point", DataPointSchema);
    DataPointHistory = framework.add_standard_collection(framework.CollectionType.DATA_POINT_HISTORY,
        "data_point_history", null);
    SensorStatus = framework.add_standard_collection(framework.CollectionType.SENSOR_STATUS,
        "sensor_status", null);

    // Listen for inserts and updates to DataPoint collection (holds current value of all datapoints)
    // and insert them into the history collection.
    // Note: DataPoint might be considered the internal staging table that we publish received readings to that other
    // components can listen to and process on. In that case, we might be considered the historical archiver component.
    var reflector_initialized = false; // avoid initial adds for existing DP entries or we'll get dups on restart
/*
    DataPoint.find().observe( {
        added: function(doc) {
            if (reflector_initialized) {
                //console.log('archived new DataPoint: ', doc.timestamp, doc.streamId, doc.data);
                dp = EJSON.clone(doc);
                delete dp['_id'];
                DataPointHistory.insert(dp);
            }
        },
        changed: function(newdoc, olddoc) {
            //console.log('archived updated DataPoint: ', newdoc.timestamp, newdoc.streamId, newdoc.data);
            var dp = EJSON.clone(newdoc);
            delete dp['_id'];
            DataPointHistory.insert(dp);
        }
    });
	*/
    Channels.find().observe( {
        added: function(doc) {
            if (reflector_initialized) {
                var tmp = EJSON.clone(doc);
                delete tmp['_id'];
                ChannelsHistory.insert(tmp);
            }
        },
        changed: function(newdoc, olddoc) {
            var tmp = EJSON.clone(newdoc);
            delete tmp['_id'];
            ChannelsHistory.insert(tmp);
        }
    });
    reflector_initialized = true;

    // code to run on server at startup
    // Manage data migrations - see https://github.com/rantav/meteor-migrations
//  Meteor.Migrations.add('addUpdateTimeToStatus', function(log) {
//    log.info("adding update times to all status items that don't have it");
//    var now = moment().valueOf();
//    SensorStatus.find({updateTime: {$exists: false}}).forEach(function(item) {
//      SensorStatus.update(item._id, {$set: {updateTime: now}});
//    });
//  });


    framework.start();

    if (userSettings.hasOwnProperty('customers')) {
        var len = userSettings.customers.length;
        for (var i = 0; i < len; i++) {
            var customer = userSettings.customers[i];
            framework.add_customer(customer);
        }
    }

    if (userSettings.hasOwnProperty('users')) {
        var len = userSettings.users.length;
        for (var i = 0; i < len; i++) {
            var user = userSettings.users[i];
            framework.add_user(user);
        }
    }

    Meteor.methods({

        // Test server-side methods scott is using to experiment with DDP
        hello: function(name) {
            return 'Hello '+name;
        },

        hello2: function(name) {
            return {
                greeting: 'Hello '+name,
                user: Meteor.user(),
                status: 'winning'
            };
        },

        // Method to update the value of a remote DIA channel - sends sci command to device
        setChannel: function(deviceId, channel, value) {
            // verify current user can access the device and associated gateway
            if (!Meteor.user() || !Meteor.user().profile) {
                return {statusCode: 403};
            }
            var creds = getDCCredentials();
            if (!creds) {
                return {statusCode: 403};
            }
            var device = Devices.findOne({_id:deviceId, customerId:Meteor.user().profile.customerId});
            if (!device)
                return {statusCode: 403};
            var gateway = Gateways.findOne({_id:device.gatewayId});
            if (!gateway)
                return {statusCode: 403};
            var oldStatus = SensorStatus.findOne({deviceId:deviceId, channel:channel});
            if (!oldStatus) { // invalid request... channel is unknown
                return {statusCode: 404};
            }
            // formulate a sci set_channel command to the device setting it to the new value
            var command =
                '<sci_request version="1.0">'+
                '  <send_message>'+
                '    <targets>'+
                '      <device id="'+gateway.name+'"/>'+
                '    </targets>'+
                '    <rci_request version="1.1">'+
                '      <do_command target="idigi_dia">'+
                '        <channel_set name="'+device.name+'.'+channel+'" value="'+value+'"/>'+
                '      </do_command>'+
                '    </rci_request>'+
                '  </send_message>'+
                '</sci_request>';
            options = {
                auth: creds.username+':'+creds.password,
                content: command
            };
            //console.log('post options: ',options);
            // pre-emptively assume it will work - to make the up more responsive
            var oldValue = oldStatus.value;
            var oldTime = oldStatus.updateTime;
            SensorStatus.update({_id:oldStatus._id},{$set: {value: value, updateTime: moment().valueOf()}});
            result = HTTP.post('http://my.idigi.com/ws/sci/.json?size=1', options);
            if (result.statusCode!=200) {
                // undo the change if it didn't work
                SensorStatus.update({_id:oldStatus._id},{$set: {value: oldValue, updateTime: oldTime}});
            }
            return {statusCode: result.statusCode};
        },
    });
});
